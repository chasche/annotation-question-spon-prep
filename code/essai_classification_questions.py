# -*- coding: utf-8 -*-
"""essai classification questions

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V8DebRrofUm2Z2LIzPSOuyrmn3sMzvq8
"""

import pandas as pd
import spacy
import nltk
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report

from google.colab import drive
drive.mount('/content/drive')

data_csv = '/content/drive/MyDrive/questions/data.csv'

data = pd.read_csv(data_csv)

X = data['question']  # Les questions
y = data['categorie']  # Les catégories

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

tfidf_vectorizer = TfidfVectorizer(max_features=200)
X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
X_test_tfidf = tfidf_vectorizer.transform(X_test)

#selected_features = ['longueur_question', 'presence_disfluences']

# Extraction de caractéristiques à partir des données d'entraînement
!python -m spacy download fr_core_news_sm

nlp = spacy.load("fr_core_news_sm")  # Modèle SpaCy pour le français

#def extract_features(text):
    #doc = nlp(text)
    #num_tokens = len(doc)
    #disfluences = len([token for token in doc if token.text == "uh" or token.text == "um"])
    #return [num_tokens, disfluences]

#X_train_features = [extract_features(text) for text in X_train]

# Extraction de caractéristiques à partir des données de test
#X_test_features = [extract_features(text) for text in X_test]

classifier = LogisticRegression()
classifier.fit(X_train_tfidf, y_train)
#classifier_features = LogisticRegression()
#classifier_features.fit(X_train_features, y_train)

# Étape 5 : Évaluation du modèle
y_pred = classifier.predict(X_test_tfidf)
#y_pred_features = classifier_features.predict(X_test_features)

accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)
#accuracy_features = accuracy_score(y_test, y_pred_features)
#report_features = classification_report(y_test, y_pred_features)

print(f'Accuracy: {accuracy}')
print(report)
#print(f'Accuracy with selected features: {accuracy_features}')
#print(report_features)

data['binary_category'] = data['categorie'].apply(lambda cat: 'question' if cat in ['spontané', 'préparé'] else 'non-question')

print(data.head(10))  # Affiche les 10 premières lignes du DataFrame

# Séparer les données en X (texte) et y (étiquette binaire)
#X = data['question']
#y_binary = data['binary_category']

#X_train, X_test, y_train, y_test = train_test_split(X, y_binary, test_size=0.25, random_state=42)

#tfidf_vectorizer = TfidfVectorizer(max_features=200)
#X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
#X_test_tfidf = tfidf_vectorizer.transform(X_test)

#classifier_binary = LogisticRegression()
#classifier_binary.fit(X_train_tfidf, y_train)

#y_pred_binary = classifier_binary.predict(X_test_tfidf)
#accuracy_binary = accuracy_score(y_test, y_pred_binary)
#report_binary = classification_report(y_test, y_pred_binary)

#print(f'Accuracy for binary classification: {accuracy_binary}')
#print(report_binary)